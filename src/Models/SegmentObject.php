<?php

declare(strict_types=1);

/*
 * SpotifyWebAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace SpotifyWebAPILib\Models;

use stdClass;

class SegmentObject implements \JsonSerializable
{
    /**
     * @var float|null
     */
    private $start;

    /**
     * @var float|null
     */
    private $duration;

    /**
     * @var float|null
     */
    private $confidence;

    /**
     * @var float|null
     */
    private $loudnessStart;

    /**
     * @var float|null
     */
    private $loudnessMax;

    /**
     * @var float|null
     */
    private $loudnessMaxTime;

    /**
     * @var float|null
     */
    private $loudnessEnd;

    /**
     * @var float[]|null
     */
    private $pitches;

    /**
     * @var float[]|null
     */
    private $timbre;

    /**
     * Returns Start.
     * The starting point (in seconds) of the segment.
     */
    public function getStart(): ?float
    {
        return $this->start;
    }

    /**
     * Sets Start.
     * The starting point (in seconds) of the segment.
     *
     * @maps start
     */
    public function setStart(?float $start): void
    {
        $this->start = $start;
    }

    /**
     * Returns Duration.
     * The duration (in seconds) of the segment.
     */
    public function getDuration(): ?float
    {
        return $this->duration;
    }

    /**
     * Sets Duration.
     * The duration (in seconds) of the segment.
     *
     * @maps duration
     */
    public function setDuration(?float $duration): void
    {
        $this->duration = $duration;
    }

    /**
     * Returns Confidence.
     * The confidence, from 0.0 to 1.0, of the reliability of the segmentation. Segments of the song which
     * are difficult to logically segment (e.g: noise) may correspond to low values in this field.
     */
    public function getConfidence(): ?float
    {
        return $this->confidence;
    }

    /**
     * Sets Confidence.
     * The confidence, from 0.0 to 1.0, of the reliability of the segmentation. Segments of the song which
     * are difficult to logically segment (e.g: noise) may correspond to low values in this field.
     *
     * @maps confidence
     */
    public function setConfidence(?float $confidence): void
    {
        $this->confidence = $confidence;
    }

    /**
     * Returns Loudness Start.
     * The onset loudness of the segment in decibels (dB). Combined with `loudness_max` and
     * `loudness_max_time`, these components can be used to describe the "attack" of the segment.
     */
    public function getLoudnessStart(): ?float
    {
        return $this->loudnessStart;
    }

    /**
     * Sets Loudness Start.
     * The onset loudness of the segment in decibels (dB). Combined with `loudness_max` and
     * `loudness_max_time`, these components can be used to describe the "attack" of the segment.
     *
     * @maps loudness_start
     */
    public function setLoudnessStart(?float $loudnessStart): void
    {
        $this->loudnessStart = $loudnessStart;
    }

    /**
     * Returns Loudness Max.
     * The peak loudness of the segment in decibels (dB). Combined with `loudness_start` and
     * `loudness_max_time`, these components can be used to describe the "attack" of the segment.
     */
    public function getLoudnessMax(): ?float
    {
        return $this->loudnessMax;
    }

    /**
     * Sets Loudness Max.
     * The peak loudness of the segment in decibels (dB). Combined with `loudness_start` and
     * `loudness_max_time`, these components can be used to describe the "attack" of the segment.
     *
     * @maps loudness_max
     */
    public function setLoudnessMax(?float $loudnessMax): void
    {
        $this->loudnessMax = $loudnessMax;
    }

    /**
     * Returns Loudness Max Time.
     * The segment-relative offset of the segment peak loudness in seconds. Combined with `loudness_start`
     * and `loudness_max`, these components can be used to desctibe the "attack" of the segment.
     */
    public function getLoudnessMaxTime(): ?float
    {
        return $this->loudnessMaxTime;
    }

    /**
     * Sets Loudness Max Time.
     * The segment-relative offset of the segment peak loudness in seconds. Combined with `loudness_start`
     * and `loudness_max`, these components can be used to desctibe the "attack" of the segment.
     *
     * @maps loudness_max_time
     */
    public function setLoudnessMaxTime(?float $loudnessMaxTime): void
    {
        $this->loudnessMaxTime = $loudnessMaxTime;
    }

    /**
     * Returns Loudness End.
     * The offset loudness of the segment in decibels (dB). This value should be equivalent to the
     * loudness_start of the following segment.
     */
    public function getLoudnessEnd(): ?float
    {
        return $this->loudnessEnd;
    }

    /**
     * Sets Loudness End.
     * The offset loudness of the segment in decibels (dB). This value should be equivalent to the
     * loudness_start of the following segment.
     *
     * @maps loudness_end
     */
    public function setLoudnessEnd(?float $loudnessEnd): void
    {
        $this->loudnessEnd = $loudnessEnd;
    }

    /**
     * Returns Pitches.
     * Pitch content is given by a “chroma” vector, corresponding to the 12 pitch classes C, C#, D to B,
     * with values ranging from 0 to 1 that describe the relative dominance of every pitch in the chromatic
     * scale. For example a C Major chord would likely be represented by large values of C, E and G (i.e.
     * classes 0, 4, and 7).
     *
     * Vectors are normalized to 1 by their strongest dimension, therefore noisy sounds are likely
     * represented by values that are all close to 1, while pure tones are described by one value at 1 (the
     * pitch) and others near 0.
     * As can be seen below, the 12 vector indices are a combination of low-power spectrum values at their
     * respective pitch frequencies.
     * ![pitch vector](https://developer.spotify.com/assets/audio/Pitch_vector.png)
     *
     * @return float[]|null
     */
    public function getPitches(): ?array
    {
        return $this->pitches;
    }

    /**
     * Sets Pitches.
     * Pitch content is given by a “chroma” vector, corresponding to the 12 pitch classes C, C#, D to B,
     * with values ranging from 0 to 1 that describe the relative dominance of every pitch in the chromatic
     * scale. For example a C Major chord would likely be represented by large values of C, E and G (i.e.
     * classes 0, 4, and 7).
     *
     * Vectors are normalized to 1 by their strongest dimension, therefore noisy sounds are likely
     * represented by values that are all close to 1, while pure tones are described by one value at 1 (the
     * pitch) and others near 0.
     * As can be seen below, the 12 vector indices are a combination of low-power spectrum values at their
     * respective pitch frequencies.
     * ![pitch vector](https://developer.spotify.com/assets/audio/Pitch_vector.png)
     *
     * @maps pitches
     *
     * @param float[]|null $pitches
     */
    public function setPitches(?array $pitches): void
    {
        $this->pitches = $pitches;
    }

    /**
     * Returns Timbre.
     * Timbre is the quality of a musical note or sound that distinguishes different types of musical
     * instruments, or voices. It is a complex notion also referred to as sound color, texture, or tone
     * quality, and is derived from the shape of a segment’s spectro-temporal surface, independently of
     * pitch and loudness. The timbre feature is a vector that includes 12 unbounded values roughly
     * centered around 0. Those values are high level abstractions of the spectral surface, ordered by
     * degree of importance.
     *
     * For completeness however, the first dimension represents the average loudness of the segment; second
     * emphasizes brightness; third is more closely correlated to the flatness of a sound; fourth to sounds
     * with a stronger attack; etc. See an image below representing the 12 basis functions (i.e. template
     * segments).
     * ![timbre basis functions](https://developer.spotify.com/assets/audio/Timbre_basis_functions.png)
     *
     * The actual timbre of the segment is best described as a linear combination of these 12 basis
     * functions weighted by the coefficient values: timbre = c1 x b1 + c2 x b2 + ... + c12 x b12, where c1
     * to c12 represent the 12 coefficients and b1 to b12 the 12 basis functions as displayed below. Timbre
     * vectors are best used in comparison with each other.
     *
     * @return float[]|null
     */
    public function getTimbre(): ?array
    {
        return $this->timbre;
    }

    /**
     * Sets Timbre.
     * Timbre is the quality of a musical note or sound that distinguishes different types of musical
     * instruments, or voices. It is a complex notion also referred to as sound color, texture, or tone
     * quality, and is derived from the shape of a segment’s spectro-temporal surface, independently of
     * pitch and loudness. The timbre feature is a vector that includes 12 unbounded values roughly
     * centered around 0. Those values are high level abstractions of the spectral surface, ordered by
     * degree of importance.
     *
     * For completeness however, the first dimension represents the average loudness of the segment; second
     * emphasizes brightness; third is more closely correlated to the flatness of a sound; fourth to sounds
     * with a stronger attack; etc. See an image below representing the 12 basis functions (i.e. template
     * segments).
     * ![timbre basis functions](https://developer.spotify.com/assets/audio/Timbre_basis_functions.png)
     *
     * The actual timbre of the segment is best described as a linear combination of these 12 basis
     * functions weighted by the coefficient values: timbre = c1 x b1 + c2 x b2 + ... + c12 x b12, where c1
     * to c12 represent the 12 coefficients and b1 to b12 the 12 basis functions as displayed below. Timbre
     * vectors are best used in comparison with each other.
     *
     * @maps timbre
     *
     * @param float[]|null $timbre
     */
    public function setTimbre(?array $timbre): void
    {
        $this->timbre = $timbre;
    }

    /**
     * Encode this object to JSON
     *
     * @param bool $asArrayWhenEmpty Whether to serialize this model as an array whenever no fields
     *        are set. (default: false)
     *
     * @return array|stdClass
     */
    #[\ReturnTypeWillChange] // @phan-suppress-current-line PhanUndeclaredClassAttribute for (php < 8.1)
    public function jsonSerialize(bool $asArrayWhenEmpty = false)
    {
        $json = [];
        if (isset($this->start)) {
            $json['start']             = $this->start;
        }
        if (isset($this->duration)) {
            $json['duration']          = $this->duration;
        }
        if (isset($this->confidence)) {
            $json['confidence']        = $this->confidence;
        }
        if (isset($this->loudnessStart)) {
            $json['loudness_start']    = $this->loudnessStart;
        }
        if (isset($this->loudnessMax)) {
            $json['loudness_max']      = $this->loudnessMax;
        }
        if (isset($this->loudnessMaxTime)) {
            $json['loudness_max_time'] = $this->loudnessMaxTime;
        }
        if (isset($this->loudnessEnd)) {
            $json['loudness_end']      = $this->loudnessEnd;
        }
        if (isset($this->pitches)) {
            $json['pitches']           = $this->pitches;
        }
        if (isset($this->timbre)) {
            $json['timbre']            = $this->timbre;
        }

        return (!$asArrayWhenEmpty && empty($json)) ? new stdClass() : $json;
    }
}
